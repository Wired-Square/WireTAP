// ui/src/stores/sessionStore.ts
//
// Centralized IO session manager for all apps (Discovery, Decoder, Transmit).
// Session lifecycle and listener management is handled by Rust backend.
// This store manages frontend state and event listeners.

import { create } from "zustand";
import { useShallow } from "zustand/react/shallow";
import { listen, type UnlistenFn } from "@tauri-apps/api/event";
import {
  createIOSession,
  getIOSessionState,
  getIOSessionCapabilities,
  startReaderSession,
  stopReaderSession,
  pauseReaderSession,
  resumeReaderSession,
  suspendReaderSession,
  resumeReaderSessionFresh,
  resumeSessionToLive,
  switchSessionToBufferReplay,
  updateReaderSpeed,
  updateReaderTimeRange,
  destroyReaderSession,
  seekReaderSession,
  seekReaderSessionByFrame,
  transitionToBufferReader,
  sessionTransmitFrame,
  registerSessionListener,
  unregisterSessionListener,
  reinitializeSessionIfSafe,
  createMultiSourceSession,
  getStateType,
  parseStateString,
  type IOCapabilities,
  type IOStateType,
  type StreamEndedPayload,
  type SessionSuspendedPayload,
  type SessionResumingPayload,
  type StateChangePayload,
  type CanTransmitFrame,
  type TransmitResult,
  type CreateIOSessionOptions,
  type FramingEncoding,
  type MultiSourceInput,
  type BusMapping,
  type PlaybackPosition,
  type RawBytesPayload,
} from "../api/io";
import type { FrameMessage } from "../types/frame";
import {
  useSessionLogStore,
  type SessionLogEventType,
} from "../apps/session-manager/stores/sessionLogStore";

// ============================================================================
// Session Logging Helper
// ============================================================================

/** Input for addSessionLog - same as LogEntry but without id/timestamp */
interface SessionLogInput {
  eventType: SessionLogEventType;
  sessionId: string | null;
  profileId: string | null;
  profileName: string | null;
  appName: string | null;
  details: string;
}

/** Safely add a session log entry (no-op if store not mounted) */
function addSessionLog(entry: SessionLogInput) {
  try {
    useSessionLogStore.getState().addEntry(entry);
  } catch {
    // Ignore if store not mounted yet
  }
}

/**
 * Special profile ID used for buffer replay (imported CSV, etc.)
 * DEPRECATED: Use isBufferProfileId() to detect buffer IDs (e.g., "buffer_1", "buffer_2")
 */
export const BUFFER_PROFILE_ID = "__imported_buffer__";

/**
 * Check if a profile ID represents a buffer session.
 * Buffer IDs follow the pattern "buf_N" (e.g., "buf_1", "buf_2")
 * generated by Rust buffer_store, or the legacy "__imported_buffer__".
 */
export function isBufferProfileId(profileId: string | null): boolean {
  if (!profileId) return false;
  return profileId === BUFFER_PROFILE_ID || /^buf_\d+$/.test(profileId);
}

/** Frame batch payload from Rust - includes active listeners for filtering */
interface FrameBatchPayload {
  frames: FrameMessage[];
  active_listeners: string[];
}

// ============================================================================
// Adaptive Frame Throttling
// ============================================================================
// Balances latency vs. UI performance with two triggers:
// 1. Batch size threshold - flush immediately when enough frames accumulate
// 2. Time interval - flush after max interval even with few frames
//
// This gives low latency for low-frequency data (flushes quickly when idle)
// while batching high-frequency data to prevent UI overload.

/** Minimum interval between flushes (ms) - prevents overwhelming UI */
const MIN_FLUSH_INTERVAL_MS = 16; // ~60fps max update rate

/** Maximum interval before forcing a flush (ms) - caps latency for sparse data */
const MAX_FLUSH_INTERVAL_MS = 50; // 20Hz minimum update rate

/** Batch size threshold - flush immediately when this many frames accumulate */
const BATCH_SIZE_THRESHOLD = 50;

/** Pending frames per session, keyed by session ID */
const pendingFramesMap = new Map<string, {
  /** Frames accumulated since last flush */
  frames: FrameMessage[];
  /** Which listeners should receive frames (empty = all) */
  activeListeners: string[];
  /** Timestamp of last flush for this session */
  lastFlushTime: number;
}>();

/** Timeout ID for the scheduled flush (null if none scheduled) */
let flushTimeoutId: ReturnType<typeof setTimeout> | null = null;

/** Getter for event listeners - set after store is created */
let getEventListeners: (() => Record<string, SessionEventListeners>) | null = null;

/** Getter for showAppError - set after store is created */
let getGlobalShowAppError: (() => ((title: string, message: string, details?: string) => void) | null) | null = null;

/** Flush all pending frames to their callbacks */
function flushPendingFrames() {
  flushTimeoutId = null;
  const now = performance.now();

  if (!getEventListeners) return;
  const eventListenersMap = getEventListeners();

  for (const [sessionId, pending] of pendingFramesMap.entries()) {
    if (pending.frames.length === 0) continue;

    const eventListeners = eventListenersMap[sessionId];
    if (!eventListeners) continue;

    // Check if any callbacks are registered before consuming frames
    // This prevents losing frames when they arrive before registerCallbacks() is called
    if (eventListeners.callbacks.size === 0) {
      // No callbacks registered yet - keep frames pending, reschedule flush
      scheduleFlush(false);
      continue;
    }

    const frames = pending.frames;
    const listeners = pending.activeListeners;

    // Clear pending before dispatching (in case callbacks add more)
    pending.frames = [];
    pending.activeListeners = [];
    pending.lastFlushTime = now;

    // Dispatch to callbacks
    for (const [listenerId, callbacks] of eventListeners.callbacks.entries()) {
      if (listeners.length === 0 || listeners.includes(listenerId)) {
        if (callbacks.onFrames) {
          callbacks.onFrames(frames);
        }
      }
    }
  }
}

/** Schedule a flush with adaptive timing */
function scheduleFlush(immediate: boolean) {
  if (immediate) {
    // Flush immediately (but still async to batch same-tick arrivals)
    if (flushTimeoutId !== null) {
      clearTimeout(flushTimeoutId);
    }
    flushTimeoutId = setTimeout(flushPendingFrames, 0);
  } else if (flushTimeoutId === null) {
    // Schedule for max interval if not already scheduled
    flushTimeoutId = setTimeout(flushPendingFrames, MAX_FLUSH_INTERVAL_MS);
  }
  // If already scheduled and not immediate, let existing timer run
}

/** Accumulate frames for throttled delivery */
function accumulateFrames(sessionId: string, frames: FrameMessage[], activeListeners: string[]) {
  // Guard against null/undefined frames (can happen during session transitions)
  if (!frames || !Array.isArray(frames)) {
    return;
  }

  const now = performance.now();
  let pending = pendingFramesMap.get(sessionId);
  if (!pending) {
    pending = { frames: [], activeListeners: [], lastFlushTime: 0 };
    pendingFramesMap.set(sessionId, pending);
  }

  // Append frames
  pending.frames.push(...frames);

  // Merge active listeners (use the most recent non-empty list)
  if (activeListeners.length > 0) {
    pending.activeListeners = activeListeners;
  }

  // Determine if we should flush immediately
  const timeSinceLastFlush = now - pending.lastFlushTime;
  const shouldFlushNow =
    pending.frames.length >= BATCH_SIZE_THRESHOLD &&
    timeSinceLastFlush >= MIN_FLUSH_INTERVAL_MS;

  scheduleFlush(shouldFlushNow);
}

// ============================================================================
// Types
// ============================================================================

/** Session lifecycle state */
export type SessionLifecycleState =
  | "disconnected"
  | "connecting"
  | "connected"
  | "error";

/** Individual session entry in the store */
export interface Session {
  /** Unique session ID (e.g., "discovery", "transmit-io_xxx-1234") */
  id: string;
  /** Profile ID this session was created from */
  profileId: string;
  /** Display name for the profile */
  profileName: string;
  /** Current lifecycle state */
  lifecycleState: SessionLifecycleState;
  /** IO state from backend (running/stopped/paused/etc) */
  ioState: IOStateType;
  /** IO capabilities (null until connected) */
  capabilities: IOCapabilities | null;
  /** Error message if lifecycleState is "error" */
  errorMessage: string | null;
  /** Number of listeners connected to this session (from Rust backend) */
  listenerCount: number;
  /** Buffer info after stream ends */
  buffer: {
    available: boolean;
    id: string | null;
    type: "frames" | "bytes" | null;
    count: number;
    /** Session ID that owns this buffer (for detecting ingest/cross-app buffers) */
    owningSessionId: string | null;
    /** Start time of captured data in microseconds (null if empty or unknown) */
    startTimeUs: number | null;
    /** End time of captured data in microseconds (null if empty or unknown) */
    endTimeUs: number | null;
  };
  /** Timestamp when session was created/joined */
  createdAt: number;
  /** Whether session has queued messages (prevents auto-removal from Transmit dropdown) */
  hasQueuedMessages: boolean;
  /** Whether the session was stopped explicitly by user (vs stream ending naturally) */
  stoppedExplicitly: boolean;
  /** Reason why the stream ended (from stream-ended event) */
  streamEndedReason: "complete" | "stopped" | "disconnected" | "error" | null;
  /** Current playback speed (null until set, 1 = realtime, 0 = unlimited) */
  speed: number | null;
  /** Current playback position (centralised for all apps sharing this session) */
  playbackPosition: PlaybackPosition | null;
}

/** Options for creating a session */
export interface CreateSessionOptions {
  /** Custom session ID (defaults to auto-generated) */
  sessionId?: string;
  /** Join existing session if profile is in use (default: true for single-handle profiles) */
  joinExisting?: boolean;
  /** Only join sessions that produce frames (not raw bytes) */
  requireFrames?: boolean;
  /** Start time for time-range capable readers (ISO-8601) */
  startTime?: string;
  /** End time for time-range capable readers (ISO-8601) */
  endTime?: string;
  /** Initial playback speed */
  speed?: number;
  /** Maximum number of frames to read */
  limit?: number;
  /** File path for file-based readers */
  filePath?: string;
  /** Use the shared buffer reader */
  useBuffer?: boolean;
  /** Framing encoding for serial readers */
  framingEncoding?: FramingEncoding;
  /** Delimiter bytes for delimiter-based framing */
  delimiter?: number[];
  /** Maximum frame length for delimiter-based framing */
  maxFrameLength?: number;
  /** Also emit raw bytes in addition to frames */
  emitRawBytes?: boolean;
  /** Minimum frame length to accept */
  minFrameLength?: number;
  /** Bus number override for single-bus devices (0-7) */
  busOverride?: number;
  /** Skip auto-starting playback sources (postgres, csv) - for connect-only mode */
  skipAutoStart?: boolean;
}

/** Payload for session-reconfigured event */
export interface SessionReconfiguredPayload {
  start: string | null;
  end: string | null;
}

/** Callbacks for a session - stored per listener in the frontend */
export interface SessionCallbacks {
  onFrames?: (frames: FrameMessage[]) => void;
  onBytes?: (payload: RawBytesPayload) => void;
  onError?: (error: string) => void;
  onTimeUpdate?: (position: PlaybackPosition) => void;
  onStreamEnded?: (payload: StreamEndedPayload) => void;
  onStreamComplete?: () => void;
  onStateChange?: (state: IOStateType) => void;
  onSpeedChange?: (speed: number) => void;
  /** Called when session is reconfigured (e.g., bookmark jump) - apps should clear state */
  onReconfigure?: (payload: SessionReconfiguredPayload) => void;
  /** Called when session is suspended (stopped with buffer available) */
  onSuspended?: (payload: SessionSuspendedPayload) => void;
  /** Called when session is resuming with a new buffer - apps should clear their frame lists */
  onResuming?: (payload: SessionResumingPayload) => void;
}

/** Session event listeners - one set per session */
interface SessionEventListeners {
  /** Unlisten functions for Tauri events */
  unlistenFunctions: UnlistenFn[];
  /** Callbacks registered by listeners, keyed by listener ID */
  callbacks: Map<string, SessionCallbacks>;
  /** Heartbeat interval ID (for keeping listeners alive in Rust backend) */
  heartbeatIntervalId: ReturnType<typeof setInterval> | null;
  /** Listener IDs that need heartbeats (separate from callbacks for timing) */
  registeredListeners: Set<string>;
}

// ============================================================================
// Store Interface
// ============================================================================

export interface SessionStore {
  // ---- Data ----
  /** All sessions keyed by session ID */
  sessions: Record<string, Session>;
  /** Currently selected session ID for transmission (Transmit app) */
  activeSessionId: string | null;
  /** Event listeners per session (frontend-only, for routing events to callbacks) */
  _eventListeners: Record<string, SessionEventListeners>;

  // ---- Multi-Bus State ----
  /** Profile IDs involved in the current multi-bus session */
  multiBusProfiles: string[];
  /** Source profile ID - preserved when switching to buffer mode */
  sourceProfileId: string | null;
  /** Maps output bus number to source info { profileName, deviceBus } */
  outputBusToSource: Map<number, { profileName: string; deviceBus: number }>;

  // ---- Actions: Session Lifecycle ----
  /** Open a session - creates if not exists, joins if exists */
  openSession: (
    profileId: string,
    profileName: string,
    listenerId: string,
    options?: CreateSessionOptions
  ) => Promise<Session>;
  /** Leave a session (unregister listener) */
  leaveSession: (sessionId: string, listenerId: string) => Promise<void>;
  /** Remove session from list entirely */
  removeSession: (sessionId: string) => Promise<void>;
  /** Clean up a session that was destroyed externally (local-only, no backend calls) */
  cleanupDestroyedSession: (sessionId: string) => void;
  /** Clean up after a listener is evicted from a session (local-only, no backend calls) */
  cleanupEvictedListener: (sessionId: string, listenerId: string) => void;
  /** Reinitialize a session with new options (atomic check via Rust) */
  reinitializeSession: (
    sessionId: string,
    listenerId: string,
    profileId: string,
    profileName: string,
    options?: CreateSessionOptions
  ) => Promise<Session>;

  // ---- Actions: Session Control ----
  /** Start streaming on a session */
  startSession: (sessionId: string) => Promise<void>;
  /** Stop streaming on a session */
  stopSession: (sessionId: string) => Promise<void>;
  /** Pause streaming on a session */
  pauseSession: (sessionId: string) => Promise<void>;
  /** Resume streaming on a session */
  resumeSession: (sessionId: string) => Promise<void>;
  /** Suspend a session - stops streaming, finalizes buffer, session stays alive */
  suspendSession: (sessionId: string) => Promise<void>;
  /** Resume a suspended session with a fresh buffer (orphans old buffer) */
  resumeSessionFresh: (sessionId: string) => Promise<void>;
  /** Update playback speed */
  setSessionSpeed: (sessionId: string, speed: number) => Promise<void>;
  /** Update time range */
  setSessionTimeRange: (
    sessionId: string,
    start?: string,
    end?: string
  ) => Promise<void>;
  /** Seek to timestamp */
  seekSession: (sessionId: string, timestampUs: number) => Promise<void>;
  /** Seek to frame index (preferred for buffer playback) */
  seekSessionByFrame: (sessionId: string, frameIndex: number) => Promise<void>;
  /** Switch to buffer replay mode */
  switchToBuffer: (sessionId: string, speed?: number) => Promise<void>;

  // ---- Actions: Transmission ----
  /** Transmit a CAN frame through a session */
  transmitFrame: (
    sessionId: string,
    frame: CanTransmitFrame
  ) => Promise<TransmitResult>;
  /** Set the active session for transmission */
  setActiveSession: (sessionId: string | null) => void;
  /** Mark session as having queued messages */
  setHasQueuedMessages: (sessionId: string, hasQueue: boolean) => void;

  // ---- Actions: Callbacks ----
  /** Register callbacks for a listener */
  registerCallbacks: (sessionId: string, listenerId: string, callbacks: SessionCallbacks) => void;
  /** Clear callbacks for a specific listener */
  clearCallbacks: (sessionId: string, listenerId: string) => void;

  // ---- Actions: Multi-Bus State ----
  /** Set profiles involved in multi-bus session */
  setMultiBusProfiles: (profiles: string[]) => void;
  /** Set source profile ID (preserved when switching to buffer) */
  setSourceProfileId: (profileId: string | null) => void;
  /** Set output bus to source mapping (output bus → { profileName, deviceBus }) */
  setOutputBusToSource: (mapping: Map<number, { profileName: string; deviceBus: number }>) => void;
  /** Reset multi-bus state (disable mode, clear profiles) */
  resetMultiBusState: () => void;

  // ---- Selectors ----
  /** Get session by ID */
  getSession: (sessionId: string) => Session | undefined;
  /** Get all sessions as array */
  getAllSessions: () => Session[];
  /** Get transmit-capable sessions */
  getTransmitCapableSessions: () => Session[];
  /** Check if profile is in use by any session */
  isProfileInUse: (profileId: string) => boolean;
  /** Get session for a profile (if one exists) */
  getSessionForProfile: (profileId: string) => Session | undefined;
  /** Get sessions for Transmit dropdown (connected + disconnected with queue) */
  getTransmitDropdownSessions: () => Session[];

  // ---- Global App Error Dialog ----
  /** Global app error dialog state (shown for errors across the app) */
  appErrorDialog: {
    isOpen: boolean;
    title: string;
    message: string;
    details: string | null;
  };
  /** Show the global app error dialog */
  showAppError: (title: string, message: string, details?: string) => void;
  /** Close the global app error dialog */
  closeAppError: () => void;
}

// ============================================================================
// Helper Functions
// ============================================================================

/** Invoke all callbacks for an event type */
function invokeCallbacks<T>(
  eventListeners: SessionEventListeners,
  eventType: keyof SessionCallbacks,
  payload: T
) {
  for (const [, callbacks] of eventListeners.callbacks.entries()) {
    const cb = callbacks[eventType] as ((arg: T) => void) | undefined;
    if (cb) {
      cb(payload);
    }
  }
}

/** Set up Tauri event listeners for a session */
async function setupSessionEventListeners(
  sessionId: string,
  eventListeners: SessionEventListeners,
  updateSession: (id: string, updates: Partial<Session>) => void
): Promise<UnlistenFn[]> {
  const unlistenFunctions: UnlistenFn[] = [];

  // Frame messages - throttled to 10Hz for UI performance
  // Frames are accumulated and flushed periodically instead of immediately dispatched
  const unlistenFrames = await listen<FrameBatchPayload>(
    `frame-message:${sessionId}`,
    (event) => {
      const { frames, active_listeners } = event.payload;
      const listeners = active_listeners ?? [];
      accumulateFrames(sessionId, frames, listeners);
    }
  );
  unlistenFunctions.push(unlistenFrames);

  // Raw bytes (serial byte streams)
  const unlistenBytes = await listen<RawBytesPayload>(
    `serial-raw-bytes:${sessionId}`,
    (event) => {
      invokeCallbacks(eventListeners, "onBytes", event.payload);
    }
  );
  unlistenFunctions.push(unlistenBytes);

  // Errors
  const unlistenError = await listen<string>(
    `session-error:${sessionId}`,
    (event) => {
      const error = event.payload;
      // Don't show error dialog for expected/transient errors
      const isExpectedError =
        error === "No IO profile configured" || error.includes("not found");
      if (!isExpectedError) {
        invokeCallbacks(eventListeners, "onError", error);
        // Show global error dialog
        // Note: showAppError will be called after store is created
        if (typeof getGlobalShowAppError === "function") {
          const showAppError = getGlobalShowAppError();
          if (showAppError) {
            showAppError("Stream Error", "An error occurred while streaming.", error);
          }
        }
      }
      updateSession(sessionId, {
        ioState: "error",
        errorMessage: error,
      });
    }
  );
  unlistenFunctions.push(unlistenError);

  // Playback time (Buffer reader, PostgreSQL reader)
  // Store position in session state for centralised access by all apps
  const unlistenPlaybackTime = await listen<PlaybackPosition>(
    `playback-time:${sessionId}`,
    (event) => {
      updateSession(sessionId, { playbackPosition: event.payload });
      invokeCallbacks(eventListeners, "onTimeUpdate", event.payload);
    }
  );
  unlistenFunctions.push(unlistenPlaybackTime);

  // Stream complete (buffer reader finished)
  const unlistenStreamComplete = await listen<boolean>(
    `stream-complete:${sessionId}`,
    () => {
      updateSession(sessionId, { ioState: "stopped" });
      invokeCallbacks(eventListeners, "onStreamComplete", undefined as never);
    }
  );
  unlistenFunctions.push(unlistenStreamComplete);

  // Stream ended (GVRET disconnect, PostgreSQL complete)
  const unlistenStreamEnded = await listen<StreamEndedPayload>(
    `stream-ended:${sessionId}`,
    (event) => {
      // Flush any pending frames before processing stream-ended
      // This ensures fast playback (e.g., PostgreSQL no-limit) delivers all frames
      flushPendingFrames();

      const payload = event.payload;
      updateSession(sessionId, {
        ioState: "stopped",
        streamEndedReason: payload.reason as Session["streamEndedReason"],
        buffer: {
          available: payload.buffer_available,
          id: payload.buffer_id,
          type: payload.buffer_type,
          count: payload.count,
          owningSessionId: payload.owning_session_id,
          startTimeUs: payload.time_range?.[0] ?? null,
          endTimeUs: payload.time_range?.[1] ?? null,
        },
      });
      invokeCallbacks(eventListeners, "onStreamEnded", payload);
    }
  );
  unlistenFunctions.push(unlistenStreamEnded);

  // State changes
  const unlistenStateChange = await listen<StateChangePayload>(
    `session-state:${sessionId}`,
    (event) => {
      const newState = parseStateString(event.payload.current);
      const errorMessage =
        newState === "error" && event.payload.current.startsWith("error:")
          ? event.payload.current.slice(6)
          : null;
      updateSession(sessionId, {
        ioState: newState,
        errorMessage,
      });
      invokeCallbacks(eventListeners, "onStateChange", newState);
    }
  );
  unlistenFunctions.push(unlistenStateChange);

  // Session reconfigured (e.g., bookmark jump) - apps should clear their state
  const unlistenReconfigured = await listen<SessionReconfiguredPayload>(
    `session-reconfigured:${sessionId}`,
    (event) => {
      console.log(`[sessionStore] Session '${sessionId}' reconfigured:`, event.payload);
      invokeCallbacks(eventListeners, "onReconfigure", event.payload);
    }
  );
  unlistenFunctions.push(unlistenReconfigured);

  // Listener count changes (from Rust backend)
  const unlistenListenerCount = await listen<{ count: number; listener_id: string | null; change: string | null }>(
    `joiner-count-changed:${sessionId}`,
    (event) => {
      updateSession(sessionId, { listenerCount: event.payload.count });
    }
  );
  unlistenFunctions.push(unlistenListenerCount);

  // Speed changes (from Rust backend - when any listener changes speed)
  const unlistenSpeedChange = await listen<number>(
    `speed-changed:${sessionId}`,
    (event) => {
      updateSession(sessionId, { speed: event.payload });
      invokeCallbacks(eventListeners, "onSpeedChange", event.payload);
    }
  );
  unlistenFunctions.push(unlistenSpeedChange);

  // Session suspended (stopped with buffer available, session stays alive)
  const unlistenSuspended = await listen<SessionSuspendedPayload>(
    `session-suspended:${sessionId}`,
    (event) => {
      const payload = event.payload;
      updateSession(sessionId, {
        ioState: "stopped",
        buffer: {
          available: payload.buffer_count > 0,
          id: payload.buffer_id,
          type: payload.buffer_type,
          count: payload.buffer_count,
          owningSessionId: sessionId,
          startTimeUs: payload.time_range?.[0] ?? null,
          endTimeUs: payload.time_range?.[1] ?? null,
        },
      });
      invokeCallbacks(eventListeners, "onSuspended", payload);
    }
  );
  unlistenFunctions.push(unlistenSuspended);

  // Session resuming (new buffer being created, apps should clear state)
  const unlistenResuming = await listen<SessionResumingPayload>(
    `session-resuming:${sessionId}`,
    (event) => {
      console.log(`[sessionStore] Session '${sessionId}' resuming with new buffer:`, event.payload);
      // Clear buffer state since we're starting fresh
      updateSession(sessionId, {
        ioState: "starting",
        stoppedExplicitly: false,
        streamEndedReason: null,
        buffer: {
          available: false,
          id: event.payload.new_buffer_id,
          type: null,
          count: 0,
          owningSessionId: sessionId,
          startTimeUs: null,
          endTimeUs: null,
        },
      });
      invokeCallbacks(eventListeners, "onResuming", event.payload);
    }
  );
  unlistenFunctions.push(unlistenResuming);

  return unlistenFunctions;
}

/** Clean up session event listeners */
function cleanupEventListeners(eventListeners: SessionEventListeners) {
  // Clear heartbeat interval
  if (eventListeners.heartbeatIntervalId) {
    clearInterval(eventListeners.heartbeatIntervalId);
    eventListeners.heartbeatIntervalId = null;
  }

  // Unlisten from Tauri events
  for (const unlisten of eventListeners.unlistenFunctions) {
    unlisten();
  }
  eventListeners.unlistenFunctions = [];
  eventListeners.callbacks.clear();
  eventListeners.registeredListeners.clear();
}

// ============================================================================
// Store Implementation
// ============================================================================

export const useSessionStore = create<SessionStore>((set, get) => ({
  // ---- Initial State ----
  sessions: {},
  activeSessionId: null,
  _eventListeners: {},
  multiBusProfiles: [],
  sourceProfileId: null,
  outputBusToSource: new Map(),
  appErrorDialog: {
    isOpen: false,
    title: "",
    message: "",
    details: null,
  },

  // ---- Session Lifecycle ----
  openSession: async (profileId, profileName, listenerId, options = {}) => {
    console.log(`[sessionStore:openSession] Called with profileId=${profileId}, profileName=${profileName}, listenerId=${listenerId}`);
    console.log(`[sessionStore:openSession] Options: ${JSON.stringify(options)}`);

    // Session ID can be explicitly provided (for recorded sources that need unique IDs)
    // or defaults to profile ID (for realtime sources that share sessions)
    const sessionId = options.sessionId ?? profileId;

    // Step 1: Check if we already have this session in our store
    const existingSession = get().sessions[sessionId];
    console.log(`[sessionStore:openSession] existingSession lifecycle=${existingSession?.lifecycleState}`);
    if (existingSession?.lifecycleState === "connected") {
      // Register this listener with Rust backend
      try {
        const result = await registerSessionListener(sessionId, listenerId);

        // Handle startup error (error that occurred before listener registered)
        if (result.startup_error) {
          get().showAppError("Stream Error", "An error occurred while starting the session.", result.startup_error);
        }

        // Add listener to heartbeat tracking
        const eventListeners = get()._eventListeners[sessionId];
        if (eventListeners) {
          eventListeners.registeredListeners.add(listenerId);
        }

        // Update session with latest info from Rust
        set((s) => ({
          sessions: {
            ...s.sessions,
            [sessionId]: {
              ...s.sessions[sessionId],
              listenerCount: result.listener_count,
            },
          },
        }));

        return get().sessions[sessionId];
      } catch {
        // Session doesn't exist in backend, will create below
      }
    }

    // Step 2: Check if session exists in backend
    const existingCaps = await getIOSessionCapabilities(sessionId);
    const existingState = await getIOSessionState(sessionId);
    const backendExists = existingCaps && existingState?.type !== "Error";
    console.log(`[sessionStore:openSession] backendExists=${backendExists}, existingState.type=${existingState?.type}`);

    // Step 3: Destroy error session if exists
    if (existingCaps && existingState?.type === "Error") {
      try {
        await destroyReaderSession(sessionId);
      } catch {
        // Ignore
      }
    }

    // Step 4: Create or join the backend session
    let capabilities: IOCapabilities;
    let ioState: IOStateType = "stopped";
    let listenerCount = 1;
    let bufferId: string | null = null;
    let bufferType: "frames" | "bytes" | null = null;

    if (backendExists) {
      // Join existing backend session using registerSessionListener only
      // Don't call joinReaderSession - it increments joiner_count separately from the listener map,
      // which causes count to overshoot when React StrictMode double-mounts components
      console.log(`[sessionStore:openSession] Backend exists, joining session ${sessionId}`);
      const regResult = await registerSessionListener(sessionId, listenerId);
      capabilities = regResult.capabilities;
      ioState = getStateType(regResult.state);
      listenerCount = regResult.listener_count;
      bufferId = regResult.buffer_id;
      bufferType = regResult.buffer_type;

      // Handle startup error (error that occurred before listener registered)
      if (regResult.startup_error) {
        get().showAppError("Stream Error", "An error occurred while starting the session.", regResult.startup_error);
      }

      // Log session-joined event
      addSessionLog({
        eventType: "session-joined",
        sessionId,
        profileId,
        profileName,
        appName: listenerId,
        details: `Joined existing session (${listenerCount} listeners, state: ${ioState})`,
      });
    } else {
      // Create new backend session
      console.log(`[sessionStore:openSession] Backend does not exist, creating new session`);
      // Auto-detect buffer mode from profile ID (supports both legacy and new buffer ID formats)
      const isBufferMode = isBufferProfileId(profileId) || options.useBuffer;
      console.log(`[sessionStore:openSession] isBufferMode=${isBufferMode}`);

      const createOptions: CreateIOSessionOptions = {
        sessionId,
        profileId: isBufferMode ? undefined : profileId, // Don't pass fake profile ID for buffer mode
        startTime: options.startTime,
        endTime: options.endTime,
        // For buffer mode, default to 1x speed (paced playback) instead of 0 (no pacing)
        speed: options.speed ?? (isBufferMode ? 1.0 : undefined),
        limit: options.limit,
        filePath: options.filePath,
        useBuffer: isBufferMode,
        framingEncoding: options.framingEncoding,
        delimiter: options.delimiter,
        maxFrameLength: options.maxFrameLength,
        emitRawBytes: options.emitRawBytes,
        minFrameLength: options.minFrameLength,
        busOverride: options.busOverride,
        listenerId, // For session logging
      };

      try {
        console.log(`[sessionStore:openSession] Calling createIOSession with options:`, JSON.stringify(createOptions));
        capabilities = await createIOSession(createOptions);
        console.log(`[sessionStore:openSession] createIOSession succeeded`);

        // Backend auto-starts the session, so query the actual state
        const currentState = await getIOSessionState(sessionId);
        if (currentState) {
          ioState = getStateType(currentState);
        }

        // Register as owner listener
        try {
          const regResult = await registerSessionListener(sessionId, listenerId);
          listenerCount = regResult.listener_count;
          // Handle startup error (error that occurred before listener registered)
          if (regResult.startup_error) {
            get().showAppError("Stream Error", "An error occurred while starting the session.", regResult.startup_error);
          }
        } catch {
          // Ignore
        }
      } catch (e) {
        const msg = e instanceof Error ? e.message : String(e);

        // If profile is in use, try to join instead using registerSessionListener only
        if (msg.includes("Profile is in use by session")) {
          const regResult = await registerSessionListener(sessionId, listenerId);
          capabilities = regResult.capabilities;
          ioState = getStateType(regResult.state);
          listenerCount = regResult.listener_count;
          bufferId = regResult.buffer_id;
          bufferType = regResult.buffer_type;

          // Handle startup error (error that occurred before listener registered)
          if (regResult.startup_error) {
            get().showAppError("Stream Error", "An error occurred while starting the session.", regResult.startup_error);
          }
        } else {
          // Create error session entry
          const errorSession: Session = {
            id: sessionId,
            profileId,
            profileName,
            lifecycleState: "error",
            ioState: "error",
            capabilities: null,
            errorMessage: msg,
            listenerCount: 0,
            buffer: { available: false, id: null, type: null, count: 0, owningSessionId: null, startTimeUs: null, endTimeUs: null },
            createdAt: Date.now(),
            hasQueuedMessages: false,
            stoppedExplicitly: false,
            streamEndedReason: null,
            speed: null,
            playbackPosition: null,
          };
          set((s) => ({
            sessions: { ...s.sessions, [sessionId]: errorSession },
          }));
          throw e;
        }
      }
    }

    // Step 5: Set up event listeners if needed
    // Use a synchronous check-and-set pattern to avoid race conditions
    // where two callers both see no event listeners and both try to create them
    let eventListeners = get()._eventListeners[sessionId];
    if (!eventListeners) {
      // Create the structure first and immediately set it in the store
      // This prevents race conditions where another caller also tries to create
      eventListeners = {
        unlistenFunctions: [],
        callbacks: new Map(),
        heartbeatIntervalId: null,
        registeredListeners: new Set(),
      };

      // Set immediately BEFORE async setup to claim the slot
      set((s) => {
        // Double-check another caller didn't beat us
        if (s._eventListeners[sessionId]) {
          // Someone else created it, use theirs
          eventListeners = s._eventListeners[sessionId];
          return s; // No change needed
        }
        return {
          ...s,
          _eventListeners: { ...s._eventListeners, [sessionId]: eventListeners! },
        };
      });

      // Re-fetch in case another caller won the race
      eventListeners = get()._eventListeners[sessionId]!;

      // Only set up Tauri listeners if we don't have any yet
      if (eventListeners.unlistenFunctions.length === 0) {
        const updateSession = (id: string, updates: Partial<Session>) => {
          set((s) => ({
            sessions: {
              ...s.sessions,
              [id]: s.sessions[id] ? { ...s.sessions[id], ...updates } : s.sessions[id],
            },
          }));
        };

        eventListeners.unlistenFunctions = await setupSessionEventListeners(
          sessionId,
          eventListeners,
          updateSession
        );

        // Start heartbeat interval to keep listeners alive in Rust backend
        // The Rust watchdog removes listeners without heartbeat after 10 seconds
        // We send heartbeats every 5 seconds to stay well within the timeout
        if (!eventListeners.heartbeatIntervalId) {
          const heartbeatSessionId = sessionId;
          eventListeners.heartbeatIntervalId = setInterval(async () => {
            const listeners = get()._eventListeners[heartbeatSessionId];
            if (!listeners || listeners.registeredListeners.size === 0) return;

            // Send heartbeat for each registered listener
            for (const lid of listeners.registeredListeners) {
              try {
                await registerSessionListener(heartbeatSessionId, lid);
              } catch {
                // Ignore heartbeat errors - session may have been destroyed
              }
            }
          }, 5000);
        }
      }
    }

    // Add this listener to the registered listeners set for heartbeat tracking
    const currentEventListeners = get()._eventListeners[sessionId];
    if (currentEventListeners) {
      currentEventListeners.registeredListeners.add(listenerId);
    }

    // Step 5.5: Start the session if it's still stopped (for playback sources like PostgreSQL, CSV)
    // Playback sources don't auto-start on the backend to avoid emitting frames before listeners are ready.
    // Now that event listeners are set up, we can safely start.
    // EXCEPTION 1: Buffer mode should NOT auto-start - data is already in the buffer store
    // and can be accessed via pagination without streaming. User can start playback manually.
    // EXCEPTION 2: skipAutoStart option - for connect-only mode (Query app) where we want
    // to create the session but not start streaming until user explicitly requests it.
    const isBufferSession = isBufferProfileId(profileId);
    const shouldAutoStart = ioState === "stopped" && !isBufferSession && !options.skipAutoStart;
    if (shouldAutoStart) {
      try {
        await startReaderSession(sessionId);
        ioState = "running";
      } catch {
        // Session might have been started by another caller - continue anyway
      }
    }

    // Step 6: Create session entry
    // IMPORTANT: Use a function updater to preserve any listenerCount updates
    // that may have occurred via events while we were setting up.
    // The `listenerCount` variable may be stale by now.
    set((s) => {
      // Check if session already exists with a higher listener count
      // (could have been updated by joiner-count-changed event)
      const existingSession = s.sessions[sessionId];
      const currentListenerCount = existingSession?.listenerCount ?? 0;
      const finalListenerCount = Math.max(listenerCount, currentListenerCount);

      const session: Session = {
        id: sessionId,
        profileId,
        profileName,
        lifecycleState: "connected",
        ioState,
        capabilities,
        errorMessage: null,
        listenerCount: finalListenerCount,
        buffer: {
          available: false,
          id: bufferId,
          type: bufferType,
          count: 0,
          owningSessionId: null,
          startTimeUs: existingSession?.buffer?.startTimeUs ?? null,
          endTimeUs: existingSession?.buffer?.endTimeUs ?? null,
        },
        createdAt: existingSession?.createdAt ?? Date.now(),
        hasQueuedMessages: existingSession?.hasQueuedMessages ?? false,
        stoppedExplicitly: existingSession?.stoppedExplicitly ?? false,
        streamEndedReason: existingSession?.streamEndedReason ?? null,
        speed: existingSession?.speed ?? null,
        playbackPosition: existingSession?.playbackPosition ?? null,
      };

      return {
        sessions: { ...s.sessions, [sessionId]: session },
      };
    });

    console.log(`[sessionStore:openSession] Complete - returning session for ${sessionId}`);
    return get().sessions[sessionId];
  },

  leaveSession: async (sessionId, listenerId) => {
    console.log(`[sessionStore:leaveSession] Called with sessionId=${sessionId}, listenerId=${listenerId}`);
    const eventListeners = get()._eventListeners[sessionId];
    console.log(`[sessionStore:leaveSession] eventListeners exists=${!!eventListeners}`);

    try {
      // Unregister listener from Rust backend
      console.log(`[sessionStore:leaveSession] Calling unregisterSessionListener...`);
      const remaining = await unregisterSessionListener(sessionId, listenerId);
      console.log(`[sessionStore:leaveSession] unregisterSessionListener returned remaining=${remaining}`);

      // Log session-left event
      const session = get().sessions[sessionId];
      addSessionLog({
        eventType: "session-left",
        sessionId,
        profileId: session?.profileId ?? null,
        profileName: session?.profileName ?? null,
        appName: listenerId,
        details: `Left session (${remaining} listeners remaining)`,
      });

      // Remove callbacks and registered listener for heartbeats
      if (eventListeners) {
        eventListeners.callbacks.delete(listenerId);
        eventListeners.registeredListeners.delete(listenerId);
        console.log(`[sessionStore:leaveSession] callbacks.size=${eventListeners.callbacks.size}`);

        // If no more local callbacks, clean up event listeners
        if (eventListeners.callbacks.size === 0) {
          console.log(`[sessionStore:leaveSession] No more callbacks, cleaning up event listeners`);
          cleanupEventListeners(eventListeners);

          // NOTE: Don't call leaveReaderSession here - unregisterSessionListener already
          // handles the backend cleanup including stopping the session when no listeners remain.
          // Calling leaveReaderSession would double-decrement joiner_count.

          const session = get().sessions[sessionId];

          // If session has queued messages, preserve it as disconnected instead of removing
          if (session?.hasQueuedMessages) {
            set((s) => {
              const { [sessionId]: __, ...remainingListeners } = s._eventListeners;
              return {
                sessions: {
                  ...s.sessions,
                  [sessionId]: {
                    ...s.sessions[sessionId],
                    lifecycleState: "disconnected",
                    listenerCount: 0,
                  },
                },
                _eventListeners: remainingListeners,
                activeSessionId:
                  s.activeSessionId === sessionId ? null : s.activeSessionId,
              };
            });
            console.log(
              `[sessionStore:leaveSession] Session preserved (has queued messages)`
            );
          } else {
            // Remove from local store only
            set((s) => {
              const { [sessionId]: _, ...remainingSessions } = s.sessions;
              const { [sessionId]: __, ...remainingListeners } = s._eventListeners;
              return {
                sessions: remainingSessions,
                _eventListeners: remainingListeners,
                activeSessionId:
                  s.activeSessionId === sessionId ? null : s.activeSessionId,
              };
            });
            console.log(`[sessionStore:leaveSession] Session removed from store`);
          }
        } else {
          // Update listener count
          console.log(`[sessionStore:leaveSession] Other callbacks remain, updating listener count`);
          set((s) => ({
            sessions: {
              ...s.sessions,
              [sessionId]: {
                ...s.sessions[sessionId],
                listenerCount: remaining,
              },
            },
          }));
        }
      }
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e);
      console.log(`[sessionStore:leaveSession] Error: ${msg}`);
      // Ignore - session may already be gone
    }
  },

  removeSession: async (sessionId) => {
    const session = get().sessions[sessionId];
    const eventListeners = get()._eventListeners[sessionId];

    if (!session) return;

    // Unregister all local listeners from Rust backend
    if (eventListeners) {
      for (const listenerId of eventListeners.registeredListeners) {
        try {
          await unregisterSessionListener(sessionId, listenerId);
        } catch {
          // Ignore - session may already be gone
        }
      }
      cleanupEventListeners(eventListeners);
    }

    // Note: Don't call leaveReaderSession - unregisterSessionListener already handles it.
    // The backend auto-destroys sessions when the last listener unregisters.

    // Clear any pending frames for this session
    pendingFramesMap.delete(sessionId);

    // Remove from store
    set((s) => {
      const { [sessionId]: _, ...remainingSessions } = s.sessions;
      const { [sessionId]: __, ...remainingListeners } = s._eventListeners;
      return {
        sessions: remainingSessions,
        _eventListeners: remainingListeners,
        activeSessionId: s.activeSessionId === sessionId ? null : s.activeSessionId,
      };
    });
  },

  cleanupDestroyedSession: (sessionId) => {
    console.log(`[sessionStore:cleanupDestroyedSession] Cleaning up session '${sessionId}' (destroyed externally)`);
    const eventListeners = get()._eventListeners[sessionId];
    if (eventListeners) {
      cleanupEventListeners(eventListeners);
    }

    // Clear any pending frames for this session
    pendingFramesMap.delete(sessionId);

    // Remove from store (no backend calls - session is already gone)
    set((s) => {
      const { [sessionId]: _, ...remainingSessions } = s.sessions;
      const { [sessionId]: __, ...remainingListeners } = s._eventListeners;
      return {
        sessions: remainingSessions,
        _eventListeners: remainingListeners,
        activeSessionId: s.activeSessionId === sessionId ? null : s.activeSessionId,
      };
    });
  },

  cleanupEvictedListener: (sessionId, listenerId) => {
    console.log(`[sessionStore:cleanupEvictedListener] Cleaning up evicted listener '${listenerId}' from session '${sessionId}'`);
    const eventListeners = get()._eventListeners[sessionId];

    if (eventListeners) {
      // Remove this listener's callback and registration
      eventListeners.callbacks.delete(listenerId);
      eventListeners.registeredListeners.delete(listenerId);

      // If no more local callbacks, full cleanup (like cleanupDestroyedSession)
      if (eventListeners.callbacks.size === 0) {
        cleanupEventListeners(eventListeners);
        pendingFramesMap.delete(sessionId);

        set((s) => {
          const { [sessionId]: _, ...remainingSessions } = s.sessions;
          const { [sessionId]: __, ...remainingListeners } = s._eventListeners;
          return {
            sessions: remainingSessions,
            _eventListeners: remainingListeners,
            activeSessionId: s.activeSessionId === sessionId ? null : s.activeSessionId,
          };
        });
      } else {
        // Other local listeners remain — just update the listener count
        set((s) => ({
          sessions: {
            ...s.sessions,
            [sessionId]: {
              ...s.sessions[sessionId],
              listenerCount: Math.max(0, (s.sessions[sessionId]?.listenerCount ?? 1) - 1),
            },
          },
        }));
      }
    }
  },

  reinitializeSession: async (sessionId, listenerId, profileId, profileName, options) => {
    console.log(`[sessionStore:reinitializeSession] Called with sessionId=${sessionId}, listenerId=${listenerId}, profileId=${profileId}, profileName=${profileName}`);
    console.log(`[sessionStore:reinitializeSession] Options: ${JSON.stringify(options)}`);

    // Use Rust's atomic reinitialize check
    const result = await reinitializeSessionIfSafe(sessionId, listenerId);
    console.log(`[sessionStore:reinitializeSession] reinitializeSessionIfSafe result: ${JSON.stringify(result)}`);

    if (!result.success) {
      // Can't fully reinitialize (other listeners exist), but we can update the time range
      const existing = get().sessions[sessionId];
      console.log(`[sessionStore:reinitializeSession] Can't reinitialize, existing session=${!!existing}`);
      if (existing) {
        // Apply time range update even when we can't reinitialize
        if (options?.startTime !== undefined || options?.endTime !== undefined) {
          console.log(`[sessionStore:reinitializeSession] Can't reinitialize (other listeners), updating time range instead`);
          await updateReaderTimeRange(sessionId, options.startTime, options.endTime);
        }
        return existing;
      }
      // If no session exists, create one
      // Pass sessionId via options so openSession uses it instead of defaulting to profileId
      console.log(`[sessionStore:reinitializeSession] No existing session, calling openSession`);
      return get().openSession(profileId, profileName, listenerId, { ...options, sessionId });
    }

    // Clean up local event listeners but keep session in store
    // This prevents React re-renders from causing the useIOSession effect
    // to try to openSession during the gap between remove and create
    const eventListeners = get()._eventListeners[sessionId];
    if (eventListeners) {
      cleanupEventListeners(eventListeners);
    }

    // Mark session as reinitializing with lifecycleState="disconnected" to prevent
    // the useIOSession effect from trying to openSession during the gap.
    // openSession checks lifecycleState !== "connected" before short-circuiting.
    set((s) => {
      const { [sessionId]: _, ..._remainingListeners } = s._eventListeners;
      return {
        sessions: {
          ...s.sessions,
          [sessionId]: {
            ...s.sessions[sessionId],
            lifecycleState: "disconnected" as const,
            ioState: "starting" as const,
          },
        },
        // Clear event listeners for this session
        _eventListeners: _remainingListeners,
      };
    });

    // Create new session - this will update the existing entry in the store
    // Pass sessionId via options so openSession uses it instead of defaulting to profileId
    console.log(`[sessionStore:reinitializeSession] Success, calling openSession for profileId=${profileId}, sessionId=${sessionId}`);
    const result2 = await get().openSession(profileId, profileName, listenerId, { ...options, sessionId });
    console.log(`[sessionStore:reinitializeSession] openSession complete, result.id=${result2?.id}`);
    return result2;
  },

  // ---- Session Control ----
  startSession: async (sessionId) => {
    const session = get().sessions[sessionId];
    if (!session || session.lifecycleState !== "connected") {
      throw new Error(`Session ${sessionId} not connected`);
    }

    // Idempotent: don't restart if already running or starting
    if (session.ioState === "running" || session.ioState === "starting") {
      return;
    }

    set((s) => ({
      sessions: {
        ...s.sessions,
        [sessionId]: {
          ...s.sessions[sessionId],
          ioState: "starting",
          stoppedExplicitly: false, // Reset flag when starting
          streamEndedReason: null, // Reset reason when starting
        },
      },
    }));

    try {
      const confirmedState = await startReaderSession(sessionId);
      set((s) => ({
        sessions: {
          ...s.sessions,
          [sessionId]: {
            ...s.sessions[sessionId],
            ioState: getStateType(confirmedState),
            errorMessage: null,
          },
        },
      }));
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e);
      set((s) => ({
        sessions: {
          ...s.sessions,
          [sessionId]: {
            ...s.sessions[sessionId],
            ioState: "error",
            errorMessage: msg,
          },
        },
      }));
      throw e;
    }
  },

  stopSession: async (sessionId) => {
    // Set stoppedExplicitly BEFORE the async call to avoid race condition:
    // The stream-ended event (which updates buffer state) may fire before
    // stopReaderSession returns. Effects checking both bufferAvailable and
    // stoppedExplicitly need both to be true at the same time.
    set((s) => ({
      sessions: {
        ...s.sessions,
        [sessionId]: {
          ...s.sessions[sessionId],
          stoppedExplicitly: true, // User explicitly stopped
        },
      },
    }));

    try {
      const confirmedState = await stopReaderSession(sessionId);
      set((s) => ({
        sessions: {
          ...s.sessions,
          [sessionId]: {
            ...s.sessions[sessionId],
            ioState: getStateType(confirmedState),
          },
        },
      }));
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e);
      if (!msg.includes("not found")) {
        throw e;
      }
    }
  },

  pauseSession: async (sessionId) => {
    const confirmedState = await pauseReaderSession(sessionId);
    set((s) => ({
      sessions: {
        ...s.sessions,
        [sessionId]: {
          ...s.sessions[sessionId],
          ioState: getStateType(confirmedState),
        },
      },
    }));
  },

  resumeSession: async (sessionId) => {
    const confirmedState = await resumeReaderSession(sessionId);
    set((s) => ({
      sessions: {
        ...s.sessions,
        [sessionId]: {
          ...s.sessions[sessionId],
          ioState: getStateType(confirmedState),
        },
      },
    }));
  },

  suspendSession: async (sessionId) => {
    // Check if the session is a realtime source - if so, switch to buffer replay mode
    // so timeline controls work. For timeline sources, just stop the reader.
    const session = get().sessions[sessionId];
    const isRealtime = session?.capabilities?.is_realtime === true;
    const profileName = session?.profileName ?? sessionId;

    if (isRealtime) {
      // Realtime source: switch to BufferReader for timeline playback
      console.log(`[sessionStore] suspendSession: realtime session '${sessionId}' - switching to buffer replay`);
      try {
        const capabilities = await switchSessionToBufferReplay(sessionId, 1.0);
        // Get buffer metadata - Rust sets the active buffer during switch, so we can query it
        const { getBufferMetadata } = await import("../api/buffer");
        const bufferMetadata = await getBufferMetadata();
        addSessionLog({
          eventType: "state-change",
          sessionId,
          profileId: session?.profileId ?? null,
          profileName,
          appName: null,
          details: `Switched to buffer replay mode (is_realtime: ${capabilities.is_realtime}, buffer: ${bufferMetadata?.id ?? 'none'})`,
        });
        set((s) => ({
          sessions: {
            ...s.sessions,
            [sessionId]: {
              ...s.sessions[sessionId],
              capabilities,
              ioState: "stopped",
              // Set buffer state so handleDetach knows a buffer exists
              buffer: bufferMetadata ? {
                available: true,
                id: bufferMetadata.id,
                type: bufferMetadata.buffer_type,
                count: bufferMetadata.count,
                owningSessionId: bufferMetadata.owning_session_id,
                startTimeUs: bufferMetadata.start_time_us,
                endTimeUs: bufferMetadata.end_time_us,
              } : s.sessions[sessionId]?.buffer ?? { available: false, id: null, type: null, count: 0, owningSessionId: null, startTimeUs: null, endTimeUs: null },
            },
          },
        }));
      } catch (e) {
        const msg = e instanceof Error ? e.message : String(e);
        console.error(`[sessionStore] suspendSession: failed to switch to buffer replay: ${msg}`);
        addSessionLog({
          eventType: "session-error",
          sessionId,
          profileId: session?.profileId ?? null,
          profileName,
          appName: null,
          details: `Failed to switch to buffer replay: ${msg}`,
        });
        // Fall back to just stopping the reader
        try {
          const confirmedState = await suspendReaderSession(sessionId);
          set((s) => ({
            sessions: {
              ...s.sessions,
              [sessionId]: {
                ...s.sessions[sessionId],
                ioState: getStateType(confirmedState),
              },
            },
          }));
        } catch (fallbackError) {
          console.error(`[sessionStore] suspendSession: fallback also failed:`, fallbackError);
        }
      }
    } else {
      // Timeline source: just stop the reader
      console.log(`[sessionStore] suspendSession: timeline session '${sessionId}' - stopping reader`);
      const confirmedState = await suspendReaderSession(sessionId);
      set((s) => ({
        sessions: {
          ...s.sessions,
          [sessionId]: {
            ...s.sessions[sessionId],
            ioState: getStateType(confirmedState),
          },
        },
      }));
    }
  },

  resumeSessionFresh: async (sessionId) => {
    // Clear stopped flags before resuming
    set((s) => ({
      sessions: {
        ...s.sessions,
        [sessionId]: {
          ...s.sessions[sessionId],
          stoppedExplicitly: false,
          streamEndedReason: null,
        },
      },
    }));

    // Try to resume to live first (for realtime sources that were suspended to buffer mode)
    // This will fail if the session doesn't have stored profile IDs (timeline sources)
    try {
      console.log(`[sessionStore] resumeSessionFresh: trying resumeSessionToLive for '${sessionId}'`);
      const capabilities = await resumeSessionToLive(sessionId);
      // Success - session is now back in live mode with a fresh buffer
      console.log(`[sessionStore] resumeSessionFresh: '${sessionId}' resumed to live mode`);
      set((s) => ({
        sessions: {
          ...s.sessions,
          [sessionId]: {
            ...s.sessions[sessionId],
            capabilities,
            ioState: "running",
          },
        },
      }));
    } catch (e) {
      // No profile IDs stored (timeline source) - use the existing resume logic
      console.log(`[sessionStore] resumeSessionFresh: '${sessionId}' falling back to resumeReaderSessionFresh - ${e}`);
      const confirmedState = await resumeReaderSessionFresh(sessionId);
      set((s) => ({
        sessions: {
          ...s.sessions,
          [sessionId]: {
            ...s.sessions[sessionId],
            ioState: getStateType(confirmedState),
          },
        },
      }));
    }
  },

  setSessionSpeed: async (sessionId, speed) => {
    await updateReaderSpeed(sessionId, speed);
  },

  setSessionTimeRange: async (sessionId, start, end) => {
    console.log("[sessionStore:setSessionTimeRange] sessionId:", sessionId, "start:", start, "end:", end);
    await updateReaderTimeRange(sessionId, start, end);
    console.log("[sessionStore:setSessionTimeRange] completed");
  },

  seekSession: async (sessionId, timestampUs) => {
    await seekReaderSession(sessionId, timestampUs);
  },

  seekSessionByFrame: async (sessionId, frameIndex) => {
    await seekReaderSessionByFrame(sessionId, frameIndex);
    // Update local playback position immediately so UI reflects the seek
    // (Backend will emit position events during playback, but we need immediate feedback for seeks while paused)
    set((s) => {
      const session = s.sessions[sessionId];
      if (!session) return s;
      return {
        sessions: {
          ...s.sessions,
          [sessionId]: {
            ...session,
            playbackPosition: {
              // Keep existing timestamp or default to 0 (frame index is what matters for position display)
              timestamp_us: session.playbackPosition?.timestamp_us ?? 0,
              frame_index: frameIndex,
            },
          },
        },
      };
    });
  },

  switchToBuffer: async (sessionId, speed) => {
    const capabilities = await transitionToBufferReader(sessionId, speed);
    set((s) => ({
      sessions: {
        ...s.sessions,
        [sessionId]: {
          ...s.sessions[sessionId],
          capabilities,
          ioState: "stopped",
          buffer: { available: false, id: null, type: null, count: 0, owningSessionId: null, startTimeUs: null, endTimeUs: null },
        },
      },
    }));
  },

  // ---- Transmission ----
  transmitFrame: async (sessionId, frame) => {
    const session = get().sessions[sessionId];
    if (!session) {
      throw new Error(`Session ${sessionId} not found`);
    }
    if (!session.capabilities?.can_transmit) {
      throw new Error(`Session ${sessionId} does not support transmission`);
    }
    return sessionTransmitFrame(sessionId, frame);
  },

  setActiveSession: (sessionId) => {
    set({ activeSessionId: sessionId });
  },

  setHasQueuedMessages: (sessionId, hasQueue) => {
    set((s) => ({
      sessions: {
        ...s.sessions,
        [sessionId]: {
          ...s.sessions[sessionId],
          hasQueuedMessages: hasQueue,
        },
      },
    }));
  },

  // ---- Callbacks ----
  registerCallbacks: (sessionId, listenerId, callbacks) => {
    const eventListeners = get()._eventListeners[sessionId];
    if (eventListeners) {
      eventListeners.callbacks.set(listenerId, callbacks);
    }
  },

  clearCallbacks: (sessionId, listenerId) => {
    const eventListeners = get()._eventListeners[sessionId];
    if (eventListeners) {
      eventListeners.callbacks.delete(listenerId);
    }
  },

  // ---- Multi-Bus State ----
  setMultiBusProfiles: (profiles) => set({ multiBusProfiles: profiles }),

  setSourceProfileId: (profileId) => set({ sourceProfileId: profileId }),

  setOutputBusToSource: (mapping) => set({ outputBusToSource: mapping }),

  resetMultiBusState: () => set({
    multiBusProfiles: [],
    sourceProfileId: null,
    outputBusToSource: new Map(),
  }),

  // ---- Selectors ----
  getSession: (sessionId) => get().sessions[sessionId],

  getAllSessions: () => Object.values(get().sessions).filter((s) => s != null),

  getTransmitCapableSessions: () =>
    Object.values(get().sessions).filter(
      (s) =>
        s && s.lifecycleState === "connected" && s.capabilities?.can_transmit === true
    ),

  isProfileInUse: (profileId) =>
    Object.values(get().sessions).some(
      (s) => s && s.profileId === profileId && s.lifecycleState === "connected"
    ),

  getSessionForProfile: (profileId) =>
    Object.values(get().sessions).find(
      (s) => s && s.profileId === profileId && s.lifecycleState === "connected"
    ),

  getTransmitDropdownSessions: () =>
    Object.values(get().sessions).filter(
      (s) =>
        s &&
        ((s.lifecycleState === "connected" &&
          s.capabilities?.can_transmit === true) ||
        (s.lifecycleState === "disconnected" && s.hasQueuedMessages))
    ),

  // ---- Global App Error Dialog ----
  showAppError: (title, message, details) =>
    set({
      appErrorDialog: {
        isOpen: true,
        title,
        message,
        details: details ?? null,
      },
    }),

  closeAppError: () =>
    set({
      appErrorDialog: {
        isOpen: false,
        title: "",
        message: "",
        details: null,
      },
    }),
}));

// Initialize the event listeners getter for frame throttling
getEventListeners = () => useSessionStore.getState()._eventListeners;

// Initialize the showAppError getter for error handling
getGlobalShowAppError = () => useSessionStore.getState().showAppError;

// ============================================================================
// Convenience Hooks
// ============================================================================

/** Get a specific session by ID */
export function useSession(sessionId: string): Session | undefined {
  return useSessionStore((s) => s.sessions[sessionId]);
}

/** Get the active session for transmission */
export function useActiveSession(): Session | undefined {
  return useSessionStore((s) =>
    s.activeSessionId ? s.sessions[s.activeSessionId] : undefined
  );
}

/** Get all sessions as an array */
export function useAllSessions(): Session[] {
  return useSessionStore(
    useShallow((s) => Object.values(s.sessions))
  );
}

/** Get transmit-capable sessions */
export function useTransmitCapableSessions(): Session[] {
  return useSessionStore(
    useShallow((s) =>
      Object.values(s.sessions).filter(
        (session) =>
          session.lifecycleState === "connected" &&
          session.capabilities?.can_transmit === true
      )
    )
  );
}

/** Get sessions for Transmit dropdown */
export function useTransmitDropdownSessions(): Session[] {
  return useSessionStore(
    useShallow((s) =>
      Object.values(s.sessions).filter(
        (session) =>
          (session.lifecycleState === "connected" &&
            session.capabilities?.can_transmit === true) ||
          (session.lifecycleState === "disconnected" && session.hasQueuedMessages)
      )
    )
  );
}

/** Hook for global app error dialog state and actions */
export function useAppErrorDialog() {
  const isOpen = useSessionStore((s) => s.appErrorDialog.isOpen);
  const title = useSessionStore((s) => s.appErrorDialog.title);
  const message = useSessionStore((s) => s.appErrorDialog.message);
  const details = useSessionStore((s) => s.appErrorDialog.details);
  const closeAppError = useSessionStore((s) => s.closeAppError);

  return { isOpen, title, message, details, closeAppError };
}

/** Source info for a bus in multi-bus mode */
export interface BusSourceInfo {
  profileName: string;
  deviceBus: number;
}

/** Multi-bus state returned by useMultiBusState hook */
export interface MultiBusState {
  /** Profile IDs in the multi-bus session */
  multiBusProfiles: string[];
  /** Source profile ID (preserved when switching to buffer) */
  sourceProfileId: string | null;
  /** Maps output bus number to source info */
  outputBusToSource: Map<number, BusSourceInfo>;
  /** Set profiles in multi-bus session */
  setMultiBusProfiles: (profiles: string[]) => void;
  /** Set source profile ID */
  setSourceProfileId: (profileId: string | null) => void;
  /** Set output bus to source mapping */
  setOutputBusToSource: (mapping: Map<number, BusSourceInfo>) => void;
  /** Reset all multi-bus state */
  resetMultiBusState: () => void;
}

/** Get multi-bus state and setters */
export function useMultiBusState(): MultiBusState {
  return useSessionStore(
    useShallow((s) => ({
      multiBusProfiles: s.multiBusProfiles,
      sourceProfileId: s.sourceProfileId,
      outputBusToSource: s.outputBusToSource,
      setMultiBusProfiles: s.setMultiBusProfiles,
      setSourceProfileId: s.setSourceProfileId,
      setOutputBusToSource: s.setOutputBusToSource,
      resetMultiBusState: s.resetMultiBusState,
    }))
  );
}

// ============================================================================
// Multi-Source Session Helpers
// ============================================================================

/**
 * Per-interface framing configuration (simplified for UI).
 * Used when each serial interface in a multi-source session needs different framing.
 */
export interface PerInterfaceFramingConfig {
  /** Framing encoding: "raw", "slip", "modbus_rtu", "delimiter" */
  encoding: FramingEncoding;
  /** Delimiter hex string for delimiter mode (e.g., "0D0A") */
  delimiterHex?: string;
}

/**
 * Options for creating a multi-source session.
 */
export interface CreateMultiSourceOptions {
  /** Unique session ID for the merged session (e.g., "discovery-multi") */
  sessionId: string;
  /** Listener ID for this app (e.g., "discovery", "decoder") */
  listenerId: string;
  /** Profile IDs to combine */
  profileIds: string[];
  /** Bus mappings per profile (keyed by profile ID) */
  busMappings?: Map<string, BusMapping[]>;
  /** Map of profile ID to display name */
  profileNames?: Map<string, string>;
  /** Framing encoding for serial sources (e.g., "slip", "delimiter", "modbus_rtu", "raw") */
  framingEncoding?: string;
  /** Delimiter bytes for delimiter-based framing */
  delimiter?: number[];
  /** Maximum frame length for delimiter-based framing */
  maxFrameLength?: number;
  /** Minimum frame length - frames shorter than this are discarded */
  minFrameLength?: number;
  /** Whether to emit raw bytes in addition to framed data */
  emitRawBytes?: boolean;
  /** Per-interface framing config (overrides session-level framing for specific profiles) */
  perInterfaceFraming?: Map<string, PerInterfaceFramingConfig>;
  /** Frame ID extraction: start byte position (0-indexed) */
  frameIdStartByte?: number;
  /** Frame ID extraction: number of bytes (1 or 2) */
  frameIdBytes?: number;
  /** Frame ID extraction: byte order (true = big endian) */
  frameIdBigEndian?: boolean;
  /** Source address extraction: start byte position (0-indexed) */
  sourceAddressStartByte?: number;
  /** Source address extraction: number of bytes (1 or 2) */
  sourceAddressBytes?: number;
  /** Source address extraction: byte order (true = big endian) */
  sourceAddressBigEndian?: boolean;
}

/**
 * Result of creating or joining a multi-source session.
 */
export interface MultiSourceSessionResult {
  /** The session ID */
  sessionId: string;
  /** Source profile IDs */
  sourceProfileIds: string[];
  /** The session capabilities */
  capabilities: IOCapabilities;
}

/**
 * Create a new multi-source session that merges frames from multiple devices.
 * This creates a Rust-side merged session that other apps can join.
 *
 * @param options Configuration for the multi-source session
 * @returns The session result with capabilities
 */
/**
 * Parse a hex string to byte array (e.g., "0D0A" -> [0x0D, 0x0A]).
 */
function parseHexDelimiter(hex: string): number[] {
  const bytes: number[] = [];
  for (let i = 0; i < hex.length; i += 2) {
    bytes.push(parseInt(hex.slice(i, i + 2), 16));
  }
  return bytes;
}

export async function createAndStartMultiSourceSession(
  options: CreateMultiSourceOptions
): Promise<MultiSourceSessionResult> {
  const {
    sessionId,
    listenerId,
    profileIds,
    busMappings,
    profileNames,
    framingEncoding,
    delimiter,
    maxFrameLength,
    minFrameLength,
    emitRawBytes,
    perInterfaceFraming,
    frameIdStartByte,
    frameIdBytes,
    frameIdBigEndian,
    sourceAddressStartByte,
    sourceAddressBytes,
    sourceAddressBigEndian,
  } = options;

  // Build source configs with bus mappings and framing config
  const sources: MultiSourceInput[] = profileIds.map((profileId) => {
    // Check for per-interface framing override
    const interfaceFraming = perInterfaceFraming?.get(profileId);

    // Use per-interface framing if specified, otherwise fall back to session-level
    const sourceFramingEncoding = interfaceFraming?.encoding ?? framingEncoding;
    const sourceDelimiter = interfaceFraming?.delimiterHex
      ? parseHexDelimiter(interfaceFraming.delimiterHex)
      : delimiter;

    // For "raw" framing mode, set emitRawBytes to true
    const sourceEmitRawBytes = sourceFramingEncoding === "raw" ? true : emitRawBytes;

    return {
      profileId,
      displayName: profileNames?.get(profileId),
      busMappings: busMappings?.get(profileId) || [],
      // Apply framing config (per-interface or session-level)
      // Serial sources will use these overrides, CAN sources will ignore them
      framingEncoding: sourceFramingEncoding,
      delimiter: sourceDelimiter,
      maxFrameLength,
      minFrameLength,
      emitRawBytes: sourceEmitRawBytes,
      // Frame ID extraction config (from catalog)
      frameIdStartByte,
      frameIdBytes,
      frameIdBigEndian,
      sourceAddressStartByte,
      sourceAddressBytes,
      sourceAddressBigEndian,
    };
  });

  // Create the multi-source session in Rust
  const capabilities = await createMultiSourceSession({
    sessionId,
    sources,
    listenerId,
  });

  // Register this listener with the session
  const regResult = await registerSessionListener(sessionId, listenerId);
  // Handle startup error (error that occurred before listener registered)
  if (regResult.startup_error) {
    useSessionStore.getState().showAppError("Stream Error", "An error occurred while starting the session.", regResult.startup_error);
  }

  // Set up event listeners and heartbeat interval
  // This is needed because useIOSession's effect may skip setup when the session ID changes
  // during multi-bus session creation (to avoid stale closure issues)
  const store = useSessionStore.getState();
  let eventListeners = store._eventListeners[sessionId];
  if (!eventListeners) {
    eventListeners = {
      unlistenFunctions: [],
      callbacks: new Map(),
      heartbeatIntervalId: null,
      registeredListeners: new Set(),
    };

    useSessionStore.setState((s) => {
      if (s._eventListeners[sessionId]) {
        eventListeners = s._eventListeners[sessionId];
        return s;
      }
      return {
        ...s,
        _eventListeners: { ...s._eventListeners, [sessionId]: eventListeners! },
      };
    });

    eventListeners = useSessionStore.getState()._eventListeners[sessionId]!;

    if (eventListeners.unlistenFunctions.length === 0) {
      const updateSession = (id: string, updates: Partial<Session>) => {
        useSessionStore.setState((s) => ({
          sessions: {
            ...s.sessions,
            [id]: s.sessions[id] ? { ...s.sessions[id], ...updates } : s.sessions[id],
          },
        }));
      };

      eventListeners.unlistenFunctions = await setupSessionEventListeners(
        sessionId,
        eventListeners,
        updateSession
      );

      // Start heartbeat interval to keep listeners alive in Rust backend
      if (!eventListeners.heartbeatIntervalId) {
        const heartbeatSessionId = sessionId;
        eventListeners.heartbeatIntervalId = setInterval(async () => {
          const listeners = useSessionStore.getState()._eventListeners[heartbeatSessionId];
          if (!listeners || listeners.registeredListeners.size === 0) return;

          for (const lid of listeners.registeredListeners) {
            try {
              await registerSessionListener(heartbeatSessionId, lid);
            } catch {
              // Ignore heartbeat errors - session may have been destroyed
            }
          }
        }, 5000);
      }
    }
  }

  // Add this listener to the registered listeners set for heartbeat tracking
  eventListeners.registeredListeners.add(listenerId);

  return {
    sessionId,
    sourceProfileIds: profileIds,
    capabilities,
  };
}

/**
 * Options for joining an existing multi-source session.
 */
export interface JoinMultiSourceOptions {
  /** Session ID to join */
  sessionId: string;
  /** Listener ID for this app */
  listenerId: string;
  /** Source profile IDs (for display purposes) */
  sourceProfileIds?: string[];
}

/**
 * Join an existing multi-source session (created by another app).
 * This connects to an already-running merged session.
 *
 * @param options Configuration for joining the session
 * @returns The session result with capabilities
 */
export async function joinMultiSourceSession(
  options: JoinMultiSourceOptions
): Promise<MultiSourceSessionResult> {
  const { sessionId, listenerId, sourceProfileIds = [] } = options;

  // Join the existing session using registerSessionListener only
  // Don't call joinReaderSession - it increments joiner_count separately from the listener map
  const regResult = await registerSessionListener(sessionId, listenerId);
  // Handle startup error (error that occurred before listener registered)
  if (regResult.startup_error) {
    useSessionStore.getState().showAppError("Stream Error", "An error occurred while starting the session.", regResult.startup_error);
  }

  // Set up event listeners and heartbeat interval if not already set up
  const store = useSessionStore.getState();
  let eventListeners = store._eventListeners[sessionId];
  if (!eventListeners) {
    eventListeners = {
      unlistenFunctions: [],
      callbacks: new Map(),
      heartbeatIntervalId: null,
      registeredListeners: new Set(),
    };

    useSessionStore.setState((s) => {
      if (s._eventListeners[sessionId]) {
        eventListeners = s._eventListeners[sessionId];
        return s;
      }
      return {
        ...s,
        _eventListeners: { ...s._eventListeners, [sessionId]: eventListeners! },
      };
    });

    eventListeners = useSessionStore.getState()._eventListeners[sessionId]!;

    if (eventListeners.unlistenFunctions.length === 0) {
      const updateSession = (id: string, updates: Partial<Session>) => {
        useSessionStore.setState((s) => ({
          sessions: {
            ...s.sessions,
            [id]: s.sessions[id] ? { ...s.sessions[id], ...updates } : s.sessions[id],
          },
        }));
      };

      eventListeners.unlistenFunctions = await setupSessionEventListeners(
        sessionId,
        eventListeners,
        updateSession
      );

      // Start heartbeat interval to keep listeners alive in Rust backend
      if (!eventListeners.heartbeatIntervalId) {
        const heartbeatSessionId = sessionId;
        eventListeners.heartbeatIntervalId = setInterval(async () => {
          const listeners = useSessionStore.getState()._eventListeners[heartbeatSessionId];
          if (!listeners || listeners.registeredListeners.size === 0) return;

          for (const lid of listeners.registeredListeners) {
            try {
              await registerSessionListener(heartbeatSessionId, lid);
            } catch {
              // Ignore heartbeat errors - session may have been destroyed
            }
          }
        }, 5000);
      }
    }
  }

  // Add this listener to the registered listeners set for heartbeat tracking
  eventListeners.registeredListeners.add(listenerId);

  return {
    sessionId,
    sourceProfileIds,
    capabilities: regResult.capabilities,
  };
}
